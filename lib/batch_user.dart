import 'package:flutter/services.dart';

/// Provides user related functionality, such as custom data and events.
/// Do not instantiate this: use the `instance` static property.
class BatchUser {
  static const MethodChannel _channel =
      const MethodChannel('batch_flutter.user');

  /// Batch User module singleton.
  static BatchUser instance = new BatchUser();

  /// Get the user identifier.
  /// Returns null if you didn't set one.
  Future<String?> get identifier async {
    return await _channel.invokeMethod('user.getIdentifier');
  }

  /// Get the language override.
  /// Returns null if you didn't set a custom language.
  Future<String?> get language async {
    return await _channel.invokeMethod('user.getLanguage');
  }

  /// Get the region override.
  /// Returns null if you didn't set a custom language.
  Future<String?> get region async {
    return await _channel.invokeMethod('user.getRegion');
  }

  /// Get the unique Installation ID, generated by the SDK.
  Future<String?> get installationID async {
    return await _channel.invokeMethod('user.getInstallationID');
  }

  /// Clear all tags and attributes set on an installation and their local cache
  /// returned by [attributes] and [tagCollections].
  /// This does not affect data set on profiles using [BatchProfile].
  void clearInstallationData() {
     _channel.invokeMethod('user.clearInstallationData');
  }

  /// Read the saved attributes.
  /// Reading is asynchronous so as not to interfere with saving operations.
  Future<Map<String, BatchUserAttribute>> get attributes async {
    Map<String, Map<dynamic, dynamic>>? rawAttributes =
        await _channel.invokeMapMethod("user.fetch.attributes");

    if (rawAttributes == null) {
      throw BatchUserInternalError(code: 1);
    }

    Map<String, BatchUserAttribute> attributes = {};
    rawAttributes.forEach((key, rawTypedValue) {
      dynamic castedValue;
      BatchUserAttributeType type;
      dynamic rawValue = rawTypedValue["value"];

      if (rawValue == null) {
        throw BatchUserInternalError(code: 2);
      }

      String? rawType = rawTypedValue["type"];
      switch (rawType) {
        case "d":
          type = BatchUserAttributeType.date;
          int rawDate = rawValue as int;
          castedValue =
              DateTime.fromMillisecondsSinceEpoch(rawDate, isUtc: true);
          break;
        case "i":
          type = BatchUserAttributeType.integer;
          castedValue = rawValue as int;
          break;
        case "f":
          type = BatchUserAttributeType.double;
          castedValue = rawValue as double;
          break;
        case "b":
          type = BatchUserAttributeType.boolean;
          castedValue = rawValue as bool;
          break;
        case "s":
          type = BatchUserAttributeType.string;
          castedValue = rawValue as String;
          break;
        case "u":
          type = BatchUserAttributeType.url;
          castedValue = Uri.parse(rawValue as String);
          break;
        default:
          throw BatchUserInternalError(code: 3);
      }

      attributes[key] = BatchUserAttribute(type: type, value: castedValue);
    });
    return attributes;
  }

  /// Read the saved tag collections.
  /// Reading is asynchronous so as not to interfere with saving operations.
  Future<Map<String, List<String>>> get tagCollections async {
    Map<String, List<dynamic>>? rawTagCollections =
        await _channel.invokeMapMethod("user.fetch.tags");

    if (rawTagCollections == null) {
      throw BatchUserInternalError(code: 4);
    }

    Map<String, List<String>> castedTagCollections = {};
    rawTagCollections.forEach((key, value) {
      List<String> tags = List.castFrom(value);
      castedTagCollections[key] = tags;
    });
    return castedTagCollections;
  }
}

/// Object representing a user attribute.
/// An attribute is represented by it's type, which maches the one you've used
/// when setting the attribute, and its value.
///
/// You can get the attribute using the generic getter, or use the typed ones
/// that will cast the value or return null if the type doesn't match.
class BatchUserAttribute {
  BatchUserAttribute({required this.type, required this.value});

  final BatchUserAttributeType type;
  final dynamic value;

  String? getStringValue() {
    if (type == BatchUserAttributeType.string) {
      return value;
    }
    return null;
  }

  DateTime? getDateValue() {
    if (type == BatchUserAttributeType.date) {
      return value;
    }
    return null;
  }

  int? getIntegerValue() {
    if (type == BatchUserAttributeType.integer) {
      return value;
    }
    return null;
  }

  double? getDoubleValue() {
    if (type == BatchUserAttributeType.double) {
      return value;
    }
    return null;
  }

  bool? getBoolValue() {
    if (type == BatchUserAttributeType.boolean) {
      return value;
    }
    return null;
  }

  Uri? getUriValue() {
    if (type == BatchUserAttributeType.url) {
      return value;
    }
    return null;
  }

  @override
  String toString() {
    return ("${value.toString()} (${type.toString()})");
  }
}

/// User attribute types.
enum BatchUserAttributeType { string, boolean, integer, double, date, url }

/// Error thrown when an internal user module error happens.
class BatchUserInternalError extends Error {
  BatchUserInternalError({required this.code});

  final int code;

  @override
  String toString() {
    return "BatchUserInternalError: An internal BatchUser error has occurred, something might be wrong with the native implementation. Code: $code";
  }
}
